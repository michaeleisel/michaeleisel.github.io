*TL;DR: lld is the new linker of choice for stable, as-fast-as-possible linking of debug binaries on Apple platforms. Steps on how to integrate are in the [section]() below.*

**This blog post assumes the reader is familiar with linking. If not, see [here](https://stackoverflow.com/questions/3322911/what-do-linkers-do), and if using Xcode, look for the linking step at the end of your build logs**

# Introduction

Linking is one of the main bottlenecks for incremental builds. Countless thousands developer-hours are spent each year on debug build to link, and so linker optimization is a major topic. Linkers are complicated beasts that have to do intricate transformations on huge amounts of data at lightning speed. This blog post will discuss the past, present, and future of linker optimization for Apple platforms. It also includes a [practical]() section on how to integrate lld at present.

# A Brief History of Linker Optimization


## Pre-2020

For years, linker performance didn't seem to receive that much attention. For example, when I mentioned the 20-second linking time of an app to one of Apple's linker engineers in 2017, they seemed surprised. Although the linker was undergoing active development, e.g. for Swift support, speed was not top-of-mind. Apple didn't seem to view it as a major bottleneck for third-party developers.

## The Release of zld

In the spring of 2020, I released my own fork of ld64, called zld. It added a number of optimizations on top of ld64, such as using a faster hash map implementations in key spots. There were in fact many low-hanging fruit to pick, and it ended up being about 40% faster than ld64. I could only work on zld in my spare time, since there was no major funding, but nonetheless it delivered results. Its release marked the start of a new level of focus on linker speed.

## The Revamp of lld

Soon after the release of zld, the lld linker got more resources. lld is a linker under the LLVM project that has been around for years, and supports both Apple and Linux platform. For Linux, it had long been a good choice to speed up linking, but prior to the spring of 2020 the support for Apple platforms was lacking. It didn't support many of the newer additions to ld64, and would typically error when used in an Xcode build. It seemed to be mostly used by Google and geared towards linking Chromium. However, days after the release of zld, things changed. Facebook announced on the LLVM mailing lists that they would be devoting more resources to it, and ended up putting a number of engineers on it. The goal was to make lld a viable drop-in replacement for ld64 like zld was, with better speed than zld. It had a long way to go, but it had a promising foundation. Unlike zld, which was a fork of ld64, lld was written from scratch, and was designed with speed very much in mind. For example, whereas ld64 would iterate over each of the binary's symbols many times, once for each "pass", lld tried to combine multiple passes on each symbol in each iteration. When iterating over millions of symbols in a large binary, this can be a substantial win. lld could also take learnings from optimizing Linux's lld, and rely on the LLVM project's many [optimized data structures](https://llvm.org/docs/ProgrammersManual.html#picking-the-right-data-structure-for-a-task). Over the coming months, engineers from Facebook and Google, as well as others like myself, worked on it until it could link some of the largest apps out there. It also got more testing and work from other engineers at places like Uber and Lyft to suppor their own usages of the linker, since each company's usage of it could expose new bugs and bottlenecks. Around late 2021 and early 2022, lld became a production-ready linker for apps in general, with significantly better speed than both ld64 and zld.

## Apple's Improvements to ld64

Perhaps due to all the attention linker speed was now getting in the community, Apple started optimizing ld64 in 2021 and 2022. The roadmap for the team that owns ld64 had been previously busy with things like reducing the amount of time spent in the Apple's portion of app startup time, but with the release of Xcode 14, there were a number of optimizations added to the linker, discussed in this [WWDC video](https://developer.apple.com/videos/play/wwdc2022/110362/). Now, even for developers that don't opt to use a different linker, they can expect faster linking.

What's the status of zld at present?

zld is in maintenance mode! With lld becoming a superior alternative, and with a tricky change in Xcode 14 that I [didn't want to add support for](https://github.com/michaeleisel/zld/issues/113), I decided that it was a good time to throw in the towel. zld had always been a largely unfunded project that I worked on in my spare time, and after two years of speeding up builds for developers, I could see that better-funded projects had caught up and surpassed it in 2022.

*My recommendation: try using lld for your debug builds and see if it improves the speed*

# Integrating lld

The [directions](https://lld.llvm.org/MachO/index.html) in the LLVM documention explain how to properly integrate it (don't miss the note to add `-Wl,--deduplicate-literals` if you want to be on the safe side to avoid issues when integrating). Note that the current official LLVM release also lacks a key fix to work properly with the Xcode 14 toolchain, and in general newer versions of LLVM when building Swift/Objective-C projects. For that, one should download the latest release [here](https://github.com/keith/ld64.lld/releases).

Should lld be used for release builds?

In my opinion, the answer is no, at least not right now. This is for a few reasons:
- Small differences in how lld and ld64 produce binaries can lead to app store rejectsions. For example, Apple examines metadata in the binary that indicates if ld64 was used to link the app, and if that metadata is wrong, Apple can reject the build as coming from this non-Xcode toolchain. lld is forced to imitate this metadata to essentially trick Apple into thinking that ld64 was used.
- lld lacks certain features that ld64 has. For example, ld64's chained fixups, a feature that can improve startup time, is not yet well-tested for lld. In other words, by switching to lld, one's startup time could get worse.
- ld64 is released in lockstep for each Xcode version with the other parts of the toolchain, such as clang and libLLVM. One's copy of lld may rely on a different version of LLVM, and this could theoretically cause problems. For example, there may be issues when LTO code produced by clang is given to a mismatched version of lld.

In general, lld lacks the testing and features necessary to be used in release at scale. Personally, I'm not sure this is a bad thing. Release builds don't need the same extreme speed of linking that debug builds do, and they have a greater requirement for being stable and standardized across apps. However, lld could theoretically get new optimizations that ld64 lacks that make it a worthwhile choice. It already can produce smaller binaries due to Identical Code Folding, so we'll see what happens.

# Conclusion

There will always be more work to do, wheither it's optimizing these linkers further or supporting new features like chained fixups as they're released. The landscape may change, too. It remains to be seen if [mold](https://github.com/rui314/mold), which is currently faster than lld, becomes production-ready for large apps. Apple may also try to close the gap between ld64 and these faster linkers. Linking speed has changed a lot since early 2020, and we're now seeing it get the attention it deserves.
